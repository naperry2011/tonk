(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(n){if(n.ep)return;n.ep=!0;const r=t(n);fetch(n.href,r)}})();const O=["hearts","diamonds","clubs","spades"],S=["A","2","3","4","5","6","7","8","9","10","J","Q","K"],A={hearts:"♥",diamonds:"♦",clubs:"♣",spades:"♠"};class k{constructor(e,t){this.suit=e,this.rank=t,this.value=this.calculateValue(),this.id=`${t}-${e}`}calculateValue(){return this.rank==="A"?1:["J","Q","K"].includes(this.rank)?10:parseInt(this.rank,10)}getSuitSymbol(){return A[this.suit]}isRed(){return this.suit==="hearts"||this.suit==="diamonds"}getRankIndex(){return S.indexOf(this.rank)}toString(){return`${this.rank}${this.getSuitSymbol()}`}equals(e){return this.suit===e.suit&&this.rank===e.rank}toJSON(){return{suit:this.suit,rank:this.rank}}static fromJSON(e){return new k(e.suit,e.rank)}}class C{constructor(){this.cards=[],this.discardPile=[],this.generateDeck(),this.shuffle()}generateDeck(){this.cards=[];for(const e of O)for(const t of S)this.cards.push(new k(e,t))}shuffle(){for(let e=this.cards.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[this.cards[e],this.cards[t]]=[this.cards[t],this.cards[e]]}}draw(){return this.cards.length===0?null:this.cards.pop()}discard(e){this.discardPile.push(e)}getTopDiscard(){return this.discardPile.length===0?null:this.discardPile[this.discardPile.length-1]}drawFromDiscard(){return this.discardPile.pop()}get cardsRemaining(){return this.cards.length}isEmpty(){return this.cards.length===0}reset(){this.discardPile=[],this.generateDeck(),this.shuffle()}toJSON(){return{cards:this.cards.map(e=>e.toJSON()),discardPile:this.discardPile.map(e=>e.toJSON())}}static fromJSON(e){const t=new C;return t.cards=e.cards.map(s=>k.fromJSON(s)),t.discardPile=e.discardPile.map(s=>k.fromJSON(s)),t}}const L=5,R=49,D=50,g=3,N=100;function P(o){return L}function M(o){return!0}function H(o){return o>=R&&o<=D}const i={PRE_GAME:"pre-game",INITIAL_TONK_CHECK:"initial-tonk-check",START_OF_TURN:"start-of-turn",DRAW:"draw",ACTION:"action",DISCARD:"discard",GAME_OVER:"game-over"},m={TONK:"tonk",INITIAL_TONK:"initial-tonk",KNOCK:"knock",CAUGHT:"caught",STOCK_EMPTY:"stock-empty"};class y{constructor(e,t,s){this.cards=[...e],this.type=t,this.owner=s,this.id=`spread-${Date.now()}-${Math.random().toString(36).substr(2,9)}`}static isValidBook(e){if(!e||e.length<g||e.length>4)return!1;const t=e[0].rank;return e.every(s=>s.rank===t)}static isValidRun(e){if(!e||e.length<g)return!1;const t=e[0].suit;if(!e.every(n=>n.suit===t))return!1;const s=[...e].sort((n,r)=>n.getRankIndex()-r.getRankIndex());for(let n=1;n<s.length;n++){const r=s[n-1].getRankIndex();if(s[n].getRankIndex()!==r+1)return!1}return!0}static validate(e){return y.isValidBook(e)?{valid:!0,type:"book"}:y.isValidRun(e)?{valid:!0,type:"run"}:{valid:!1,type:null}}canAddCard(e){return this.type==="book"?this.canAddToBook(e):this.type==="run"?this.canAddToRun(e):!1}canAddToBook(e){return this.cards.length>=4?!1:e.rank===this.cards[0].rank}canAddToRun(e){if(e.suit!==this.cards[0].suit)return!1;const t=[...this.cards].sort((a,d)=>a.getRankIndex()-d.getRankIndex()),s=t[0].getRankIndex(),n=t[t.length-1].getRankIndex(),r=e.getRankIndex();return r===s-1||r===n+1}addCard(e){if(!this.canAddCard(e))throw new Error("Cannot add this card to the spread");this.cards.push(e),this.type==="run"&&this.cards.sort((t,s)=>t.getRankIndex()-s.getRankIndex())}getPoints(){return this.cards.reduce((e,t)=>e+t.value,0)}getDescription(){if(this.type==="book")return`${this.cards[0].rank}s`;{const e=[...this.cards].sort((t,s)=>t.getRankIndex()-s.getRankIndex());return`${e[0].rank}-${e[e.length-1].rank} of ${this.cards[0].suit}`}}toJSON(){return{cards:this.cards.map(e=>e.toJSON()),type:this.type,ownerId:this.owner?.id||null,id:this.id}}}function f(o){const e=[],t=x(o);for(const[n,r]of Object.entries(t))r.length>=g&&e.push({type:"book",cards:r.slice(0,4)});const s=_(o);for(const[n,r]of Object.entries(s)){const a=B(r);e.push(...a.map(d=>({type:"run",cards:d})))}return e}function x(o){const e={};for(const t of o)e[t.rank]||(e[t.rank]=[]),e[t.rank].push(t);return e}function _(o){const e={};for(const t of o)e[t.suit]||(e[t.suit]=[]),e[t.suit].push(t);return e}function B(o){if(o.length<g)return[];const e=[...o].sort((n,r)=>n.getRankIndex()-r.getRankIndex()),t=[];let s=[e[0]];for(let n=1;n<e.length;n++){const r=e[n-1].getRankIndex();e[n].getRankIndex()===r+1?s.push(e[n]):(s.length>=g&&t.push([...s]),s=[e[n]])}return s.length>=g&&t.push(s),t}class T{constructor(e,t=!1){this.id=`player-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,this.name=e,this.hand=[],this.isHuman=t,this.spreads=[]}addCard(e){this.hand.push(e)}addCards(e){this.hand.push(...e)}removeCard(e){const t=this.hand.findIndex(s=>s.equals(e));return t!==-1?this.hand.splice(t,1)[0]:null}removeCards(e){const t=[];for(const s of e){const n=this.removeCard(s);n&&t.push(n)}return t}getCard(e){return this.hand[e]||null}calculatePoints(){return this.hand.reduce((e,t)=>e+t.value,0)}canKnock(){return M(this.calculatePoints())}hasEmptyHand(){return this.hand.length===0}get cardCount(){return this.hand.length}findPossibleSpreads(){return f(this.hand)}addSpread(e){this.spreads.push(e)}clearHand(){this.hand=[]}clearSpreads(){this.spreads=[]}reset(){this.clearHand(),this.clearSpreads()}getCardsSortedByValue(){return[...this.hand].sort((e,t)=>t.value-e.value)}getCardsSortedBySuit(){return[...this.hand].sort((e,t)=>e.suit!==t.suit?e.suit.localeCompare(t.suit):e.getRankIndex()-t.getRankIndex())}hasCard(e){return this.hand.some(t=>t.equals(e))}toJSON(){return{id:this.id,name:this.name,hand:this.hand.map(e=>e.toJSON()),isHuman:this.isHuman,spreads:this.spreads.map(e=>e.toJSON())}}}class $ extends T{constructor(e,t="medium"){super(e,!1),this.difficulty=t}decideDraw(e){if(!e)return"deck";const t=f(this.hand),s=[...this.hand,e];return f(s).length>t.length||this.helpsNearComplete(e)||e.value<=3&&this.hand.filter(a=>a.rank===e.rank).length>=1?"discard":"deck"}helpsNearComplete(e){if(this.hand.filter(n=>n.rank===e.rank).length>=2)return!0;const s=this.hand.filter(n=>n.suit===e.suit);for(const n of s)if(Math.abs(n.getRankIndex()-e.getRankIndex())===1){for(const a of s)if(a!==n){const d=Math.abs(a.getRankIndex()-e.getRankIndex()),h=Math.abs(a.getRankIndex()-n.getRankIndex());if(d===2||h===1)return!0}}return!1}findBestSpread(){const e=f(this.hand);return e.length===0?null:(e.sort((t,s)=>{const n=t.cards.reduce((a,d)=>a+d.value,0);return s.cards.reduce((a,d)=>a+d.value,0)-n}),e[0])}findAllSpreadsToLay(){const e=[];let t=[...this.hand];for(;;){const s=f(t);if(s.length===0)break;s.sort((r,a)=>{const d=r.cards.reduce((l,c)=>l+c.value,0);return a.cards.reduce((l,c)=>l+c.value,0)-d});const n=s[0];e.push(n);for(const r of n.cards){const a=t.findIndex(d=>d.equals(r));a!==-1&&t.splice(a,1)}}return e}findHitOpportunities(e){const t=[];for(const s of e)for(const n of this.hand)s.canAddCard(n)&&t.push({card:n,spread:s});return t.sort((s,n)=>n.card.value-s.card.value),t}decideDiscard(){const e=this.getSpreadContributingCards(),t=new Set(e.map(r=>r.id)),s=this.hand.filter(r=>!t.has(r.id));return s.length>0?(s.sort((r,a)=>a.value-r.value),s[0]):[...this.hand].sort((r,a)=>a.value-r.value)[0]}getSpreadContributingCards(){const e=new Set,t={};for(const n of this.hand)t[n.rank]||(t[n.rank]=[]),t[n.rank].push(n);for(const n of Object.values(t))n.length>=2&&n.forEach(r=>e.add(r));const s={};for(const n of this.hand)s[n.suit]||(s[n.suit]=[]),s[n.suit].push(n);for(const n of Object.values(s)){if(n.length<2)continue;const r=[...n].sort((a,d)=>a.getRankIndex()-d.getRankIndex());for(let a=0;a<r.length-1;a++){const d=r[a+1].getRankIndex()-r[a].getRankIndex();(d===1||d===2)&&(e.add(r[a]),e.add(r[a+1]))}}return[...e]}shouldKnock(){const e=this.calculatePoints();return e<=3||e<=5&&(this.countSpreadPotential()===0||this.hand.length<=2)}countSpreadPotential(){return f(this.hand).length}async executeTurn(e,t=500){const s=[];if(this.shouldKnock())return s.push({type:"knock"}),s;const n=e.getTopDiscard(),r=this.decideDraw(n);s.push({type:"draw",source:r});const a=this.findAllSpreadsToLay();for(const h of a)s.push({type:"spread",cards:h.cards,spreadType:h.type});const d=this.findHitOpportunities(e.spreadsOnTable);for(const h of d)this.hasCard(h.card)&&s.push({type:"hit",card:h.card,spread:h.spread});if(this.hand.length>0){const h=this.decideDiscard();s.push({type:"discard",card:h})}return s}}const F=["Alex","Jordan","Sam","Casey","Riley","Morgan","Taylor","Avery","Quinn","Blake","Parker","Reese","Charlie","Frankie","Jamie","Skyler","Drew","Sage","Max","Jessie","Robin","Dana","Chris","Pat"];function G(o){return[...F].sort(()=>Math.random()-.5).slice(0,o)}class K{constructor(){this.deck=null,this.players=[],this.currentPlayerIndex=0,this.phase=i.PRE_GAME,this.spreadsOnTable=[],this.winner=null,this.winCondition=null,this.turnActions=[],this.hasDrawnThisTurn=!1,this.eventListeners={},this.matchScores={},this.pointLimit=N,this.matchWinner=null,this.roundNumber=0}initialize(e,t="You"){this.deck=new C,this.players=[],this.currentPlayerIndex=0,this.phase=i.PRE_GAME,this.spreadsOnTable=[],this.winner=null,this.winCondition=null,this.turnActions=[],this.hasDrawnThisTurn=!1,this.roundNumber=1,this.matchWinner=null,this.players.push(new T(t,!0));const s=G(e-1);for(let n=0;n<e-1;n++)this.players.push(new $(s[n],"medium"));this.matchScores={};for(const n of this.players)this.matchScores[n.id]=0;this.dealAndCheckInitialTonk(),this.emit("gameInitialized",{players:this.players})}dealAndCheckInitialTonk(){this.deal(),this.phase=i.INITIAL_TONK_CHECK;const e=this.checkInitialTonk();if(e.length>1){this.emit("initialTonkDraw",{players:e});for(const t of this.players)t.reset();this.deck=new C,this.dealAndCheckInitialTonk()}else e.length===1?(this.winner=e[0],this.winCondition=m.INITIAL_TONK,this.phase=i.GAME_OVER,this.emit("gameOver",{winner:this.winner,condition:this.winCondition})):(this.phase=i.START_OF_TURN,this.emit("turnStart",{player:this.getCurrentPlayer()}))}deal(){const e=P(this.players.length);for(let s=0;s<e;s++)for(const n of this.players){const r=this.deck.draw();r&&n.addCard(r)}const t=this.deck.draw();t&&this.deck.discard(t),this.emit("cardsDealt",{cardsPerPlayer:e})}checkInitialTonk(){const e=[];for(const t of this.players)H(t.calculatePoints())&&e.push(t);return e}getCurrentPlayer(){return this.players[this.currentPlayerIndex]}isHumanTurn(){return this.getCurrentPlayer().isHuman}drawFromDeck(){if(this.phase!==i.DRAW)throw new Error("Cannot draw - not in draw phase");const e=this.deck.draw();return e?(this.getCurrentPlayer().addCard(e),this.hasDrawnThisTurn=!0,this.turnActions.push({type:"draw",source:"deck",card:e}),this.phase=i.ACTION,this.emit("cardDrawn",{player:this.getCurrentPlayer(),source:"deck",card:e}),e):(this.endGameStockEmpty(),null)}endGameStockEmpty(){let e=this.players[0],t=e.calculatePoints();for(const s of this.players){const n=s.calculatePoints();n<t&&(t=n,e=s)}this.winner=e,this.winCondition=m.STOCK_EMPTY,this.phase=i.GAME_OVER,this.emit("gameOver",{winner:this.winner,condition:this.winCondition})}drawFromDiscard(){if(this.phase!==i.DRAW)throw new Error("Cannot draw - not in draw phase");const e=this.deck.drawFromDiscard();return e&&(this.getCurrentPlayer().addCard(e),this.hasDrawnThisTurn=!0,this.turnActions.push({type:"draw",source:"discard",card:e}),this.phase=i.ACTION,this.emit("cardDrawn",{player:this.getCurrentPlayer(),source:"discard",card:e})),e}laySpread(e){if(this.phase!==i.ACTION&&this.phase!==i.START_OF_TURN)throw new Error("Cannot lay spread - not in valid phase");const t=y.validate(e);if(!t.valid)throw new Error("Invalid spread");const s=this.getCurrentPlayer();s.removeCards(e);const n=new y(e,t.type,s);return this.spreadsOnTable.push(n),s.addSpread(n),this.turnActions.push({type:"spread",cards:e,spreadType:t.type}),this.emit("spreadLaid",{player:s,spread:n}),s.hasEmptyHand()&&(this.winner=s,this.winCondition=m.TONK,this.phase=i.GAME_OVER,this.emit("gameOver",{winner:this.winner,condition:this.winCondition})),n}proceedToDraw(){if(this.phase!==i.START_OF_TURN)throw new Error("Can only proceed to draw from start of turn");this.phase=i.DRAW,this.emit("phaseChanged",{phase:i.DRAW})}hitSpread(e,t){if(this.phase!==i.ACTION&&this.phase!==i.START_OF_TURN)throw new Error("Cannot hit spread - not in valid phase");if(!t.canAddCard(e))throw new Error("Cannot add this card to the spread");const s=this.getCurrentPlayer();s.removeCard(e),t.addCard(e),this.turnActions.push({type:"hit",card:e,spreadId:t.id}),this.emit("spreadHit",{player:s,card:e,spread:t}),s.hasEmptyHand()&&(this.winner=s,this.winCondition=m.TONK,this.phase=i.GAME_OVER,this.emit("gameOver",{winner:this.winner,condition:this.winCondition}))}discard(e){if(this.phase!==i.ACTION)throw new Error("Cannot discard - not in action phase");const t=this.getCurrentPlayer(),s=t.removeCard(e);if(!s)throw new Error("Card not in player hand");if(this.deck.discard(s),this.turnActions.push({type:"discard",card:s}),this.emit("cardDiscarded",{player:t,card:s}),t.hasEmptyHand()){this.winner=t,this.winCondition=m.TONK,this.phase=i.GAME_OVER,this.emit("gameOver",{winner:this.winner,condition:this.winCondition});return}this.endTurn()}knock(){if(this.phase!==i.START_OF_TURN)throw new Error("Can only knock at the start of your turn");const e=this.getCurrentPlayer(),t=e.calculatePoints();let s=null,n=1/0;for(const r of this.players)if(r!==e){const a=r.calculatePoints();a<n&&(n=a,s=r)}t<n?(this.winner=e,this.winCondition=m.KNOCK):(this.winner=s,this.winCondition=m.CAUGHT),this.phase=i.GAME_OVER,this.emit("knock",{knocker:e,winner:this.winner}),this.emit("gameOver",{winner:this.winner,condition:this.winCondition,knocker:e})}endTurn(){this.currentPlayerIndex=(this.currentPlayerIndex+1)%this.players.length,this.hasDrawnThisTurn=!1,this.turnActions=[],this.phase=i.START_OF_TURN,this.emit("turnEnd",{nextPlayer:this.getCurrentPlayer()}),this.emit("turnStart",{player:this.getCurrentPlayer()})}isGameOver(){return this.phase===i.GAME_OVER}getScores(){return this.players.map(e=>({player:e,points:e.calculatePoints(),cardCount:e.cardCount,matchScore:this.matchScores[e.id]||0}))}getMatchScores(){return this.players.map(e=>({player:e,score:this.matchScores[e.id]||0}))}applyRoundScoring(){const e=[],t=this.winner;for(const s of this.players)if(s!==t){const n=s.calculatePoints();this.matchScores[s.id]=(this.matchScores[s.id]||0)+n,e.push({player:s,pointsAdded:n,newTotal:this.matchScores[s.id]})}return e}checkMatchEnd(){for(const e of this.players)if(this.matchScores[e.id]>=this.pointLimit){let t=this.players[0],s=this.matchScores[t.id];for(const n of this.players)this.matchScores[n.id]<s&&(s=this.matchScores[n.id],t=n);return this.matchWinner=t,!0}return!1}startNextRound(){this.roundNumber++;for(const e of this.players)e.reset();this.spreadsOnTable=[],this.winner=null,this.winCondition=null,this.hasDrawnThisTurn=!1,this.turnActions=[],this.deck=new C,this.emit("roundStart",{roundNumber:this.roundNumber}),this.dealAndCheckInitialTonk()}getTopDiscard(){return this.deck.getTopDiscard()}getDeckCount(){return this.deck.cardsRemaining}isStockEmpty(){return this.deck.isEmpty()}reset(){for(const e of this.players)e.reset();this.spreadsOnTable=[],this.winner=null,this.winCondition=null,this.currentPlayerIndex=0,this.hasDrawnThisTurn=!1,this.turnActions=[],this.phase=i.PRE_GAME}on(e,t){this.eventListeners[e]||(this.eventListeners[e]=[]),this.eventListeners[e].push(t)}off(e,t){this.eventListeners[e]&&(this.eventListeners[e]=this.eventListeners[e].filter(s=>s!==t))}emit(e,t){if(this.eventListeners[e])for(const s of this.eventListeners[e])s(t)}toJSON(){return{deck:this.deck.toJSON(),players:this.players.map(e=>e.toJSON()),currentPlayerIndex:this.currentPlayerIndex,phase:this.phase,spreadsOnTable:this.spreadsOnTable.map(e=>e.toJSON()),winner:this.winner?.id||null,winCondition:this.winCondition,hasDrawnThisTurn:this.hasDrawnThisTurn}}}class p{static createCardElement(e,t=!0,s=!1){const n=document.createElement("div");if(n.className="card",n.dataset.cardId=e.id,n.dataset.suit=e.suit,n.dataset.rank=e.rank,!t)return n.classList.add("card-back"),n;s&&n.classList.add("selectable");const r=document.createElement("div");r.className="card-corner top-left",r.innerHTML=`
      <span class="rank">${e.rank}</span>
      <span class="suit">${e.getSuitSymbol()}</span>
    `,n.appendChild(r);const a=document.createElement("div");a.className="card-center",a.innerHTML=`<span class="suit-large">${e.getSuitSymbol()}</span>`,n.appendChild(a);const d=document.createElement("div");return d.className="card-corner bottom-right",d.innerHTML=`
      <span class="rank">${e.rank}</span>
      <span class="suit">${e.getSuitSymbol()}</span>
    `,n.appendChild(d),n}static createCardBack(){const e=document.createElement("div");return e.className="card card-back",e}static createDeckStack(e){const t=document.createElement("div");t.className="deck-stack";const s=Math.min(e,5);for(let r=0;r<s;r++){const a=this.createCardBack();a.style.position="absolute",a.style.top=`${r*2}px`,a.style.left=`${r*2}px`,t.appendChild(a)}const n=document.createElement("span");return n.className="deck-count-badge",n.textContent=e,t.appendChild(n),t}static createEmptyPile(){const e=document.createElement("div");return e.className="card card-placeholder",e.innerHTML='<span class="placeholder-text">Empty</span>',e}static createSpreadElement(e){const t=document.createElement("div");t.className=`spread spread-${e.type}`,t.dataset.spreadId=e.id;const s=document.createElement("div");s.className="spread-label";const n=e.owner?e.owner.isHuman?"Your":`${e.owner.name}'s`:"",r=e.type==="book"?`${e.cards[0].rank}s`:"Run";s.textContent=n?`${n} ${r}`:r,t.appendChild(s);const a=document.createElement("div");a.className="spread-cards";for(const d of e.cards){const h=this.createCardElement(d,!0,!1);h.classList.add("spread-card"),a.appendChild(h)}return t.appendChild(a),t}static createOpponentHand(e){const t=document.createElement("div");t.className="opponent-hand",t.dataset.playerId=e.id;const s=document.createElement("div");s.className="opponent-name",s.textContent=e.name,t.appendChild(s);const n=document.createElement("div");n.className="opponent-cards";for(let a=0;a<e.cardCount;a++){const d=this.createCardBack();d.classList.add("opponent-card"),n.appendChild(d)}t.appendChild(n);const r=document.createElement("div");return r.className="opponent-info",r.textContent=`${e.cardCount} cards`,t.appendChild(r),t}static setCardSelected(e,t){t?e.classList.add("selected"):e.classList.remove("selected")}static highlightCard(e,t="default"){e.classList.add("highlighted",`highlight-${t}`)}static removeHighlight(e){e.classList.remove("highlighted","highlight-default","highlight-valid","highlight-invalid")}}class W{constructor(){this.resizeObserver=null,this.observedContainers=new Map,this.config={minVisiblePercent:.3,maxOverlap:.7,containerPadding:16},this.init()}init(){this.resizeObserver=new ResizeObserver(e=>{for(const t of e)this.updateLayout(t.target)}),window.addEventListener("orientationchange",()=>{setTimeout(()=>this.updateAllLayouts(),100)}),window.addEventListener("resize",this.debounce(()=>{this.updateAllLayouts()},150))}observe(e,t="hand"){e&&(this.observedContainers.set(e,{type:t}),this.resizeObserver.observe(e),this.updateLayout(e))}unobserve(e){e&&(this.resizeObserver.unobserve(e),this.observedContainers.delete(e))}updateLayout(e){const t=this.observedContainers.get(e);if(!t)return;const s=e.querySelectorAll(".card"),n=s.length;if(n<=1){s.forEach(l=>{l.style.marginLeft="0"});return}const r=e.clientWidth-this.config.containerPadding,a=this.getCardWidth(e,t.type),d=this.calculateOptimalOverlap(r,a,n),h=-a*d;s.forEach((l,c)=>{c>0?l.style.marginLeft=`${h}px`:l.style.marginLeft="0"}),this.updateScrollIndicator(e,r,a,n,d)}calculateOptimalOverlap(e,t,s){if(t*s<=e)return 0;const a=1-(e-t)/(s-1)/t,d=0,h=1-this.config.minVisiblePercent;return Math.min(Math.max(a,d),h)}getCardWidth(e,t){const s=getComputedStyle(document.documentElement),n=parseFloat(s.getPropertyValue("--card-width"))||70;if(t==="opponent"){const r=parseFloat(s.getPropertyValue("--card-scale-opponent"))||.65;return n*r}else if(t==="spread"){const r=parseFloat(s.getPropertyValue("--card-scale-spread"))||.7;return n*r}return n}updateScrollIndicator(e,t,s,n,r){s+(n-1)*s*(1-r)>t?e.classList.add("scrollable"):e.classList.remove("scrollable")}updateAllLayouts(){for(const e of this.observedContainers.keys())this.updateLayout(e)}debounce(e,t){let s;return(...n)=>{clearTimeout(s),s=setTimeout(()=>e.apply(this,n),t)}}destroy(){this.resizeObserver&&this.resizeObserver.disconnect(),this.observedContainers.clear()}}const v={SETTINGS:"tonk_settings"};function J(o,e){try{return localStorage.setItem(o,JSON.stringify(e)),!0}catch(t){return console.error("Failed to save to localStorage:",t),!1}}function V(o){try{const e=localStorage.getItem(o);return e?JSON.parse(e):null}catch(e){return console.error("Failed to load from localStorage:",e),null}}function U(){return{soundEnabled:!0,animationsEnabled:!0,difficulty:"medium",defaultOpponents:1,showHints:!0}}function E(){return V(v.SETTINGS)||U()}function Y(o){return J(v.SETTINGS,o)}function z(o,e){const t=E();return t[o]=e,Y(t)}function q(){return E().deckTheme||"classic"}function j(o){return z("deckTheme",o)}class Q{constructor(e){this.game=e,this.selectedCards=[],this.selectedSpread=null,this.elements={},this.messageTimeout=null,this.layoutManager=new W,this.cacheElements(),this.bindEvents(),this.bindGameEvents(),this.initializeTheme()}cacheElements(){this.elements={gameContainer:document.getElementById("game-container"),startScreen:document.getElementById("start-screen"),numPlayers:document.getElementById("num-players"),btnStartGame:document.getElementById("btn-start-game"),header:document.getElementById("game-header"),turnIndicator:document.getElementById("turn-indicator"),opponentArea:document.getElementById("opponent-area"),opponentLeftArea:document.querySelector(".opponent-left-area"),opponentRightArea:document.querySelector(".opponent-right-area"),tableArea:document.getElementById("table-area"),spreadsArea:document.getElementById("spreads-area"),deck:document.getElementById("deck"),deckCount:document.getElementById("deck-count"),discardPile:document.getElementById("discard-pile"),discardLabel:document.getElementById("discard-label"),playerArea:document.getElementById("player-area"),playerName:document.getElementById("player-name"),cardCount:document.getElementById("card-count"),pointCount:document.getElementById("point-count"),playerHand:document.getElementById("player-hand"),btnFormSpread:document.getElementById("btn-form-spread"),btnHitSpread:document.getElementById("btn-hit-spread"),btnKnock:document.getElementById("btn-knock"),btnDraw:document.getElementById("btn-draw"),btnDiscard:document.getElementById("btn-discard"),messageArea:document.getElementById("message-area"),gameOverModal:document.getElementById("game-over-modal"),gameOverTitle:document.getElementById("game-over-title"),gameOverMessage:document.getElementById("game-over-message"),finalScores:document.getElementById("final-scores"),btnNewGame:document.getElementById("btn-new-game"),btnContinueRound:document.getElementById("btn-continue-round"),rulesModal:document.getElementById("rules-modal"),btnRules:document.getElementById("btn-rules"),btnCloseRules:document.getElementById("btn-close-rules"),matchScores:document.getElementById("match-scores"),settingsModal:document.getElementById("settings-modal"),btnSettings:document.getElementById("btn-settings"),btnCloseSettings:document.getElementById("btn-close-settings"),themeOptions:document.querySelectorAll(".theme-option")}}bindEvents(){this.elements.btnStartGame.addEventListener("click",()=>{const e=parseInt(this.elements.numPlayers.value,10);this.startGame(e)}),this.elements.deck.addEventListener("click",()=>{this.canDrawFromDeck()&&this.handleDrawFromDeck()}),this.elements.discardPile.addEventListener("click",()=>{this.canDrawFromDiscard()&&this.handleDrawFromDiscard()}),this.elements.btnFormSpread.addEventListener("click",()=>{this.handleFormSpread()}),this.elements.btnHitSpread.addEventListener("click",()=>{this.handleHitSpread()}),this.elements.btnKnock.addEventListener("click",()=>{this.handleKnock()}),this.elements.btnDraw.addEventListener("click",()=>{this.handleProceedToDraw()}),this.elements.btnDiscard.addEventListener("click",()=>{this.handleDiscard()}),this.elements.btnNewGame.addEventListener("click",()=>{this.elements.gameOverModal.classList.add("hidden"),this.elements.startScreen.classList.remove("hidden")}),this.elements.btnContinueRound.addEventListener("click",()=>{this.elements.gameOverModal.classList.add("hidden"),this.game.startNextRound()}),this.elements.btnRules.addEventListener("click",()=>{this.elements.rulesModal.classList.remove("hidden")}),this.elements.btnCloseRules.addEventListener("click",()=>{this.elements.rulesModal.classList.add("hidden")}),this.elements.rulesModal.addEventListener("click",e=>{e.target===this.elements.rulesModal&&this.elements.rulesModal.classList.add("hidden")}),this.elements.btnSettings.addEventListener("click",()=>{this.elements.settingsModal.classList.remove("hidden")}),this.elements.btnCloseSettings.addEventListener("click",()=>{this.elements.settingsModal.classList.add("hidden")}),this.elements.settingsModal.addEventListener("click",e=>{e.target===this.elements.settingsModal&&this.elements.settingsModal.classList.add("hidden")}),this.elements.themeOptions.forEach(e=>{e.addEventListener("click",()=>{const t=e.dataset.theme;this.setDeckTheme(t)})})}bindGameEvents(){this.game.on("gameInitialized",()=>{this.render()}),this.game.on("turnStart",e=>{this.selectedCards=[],this.selectedSpread=null,this.render(),e.player.isHuman||this.handleAITurn(e.player)}),this.game.on("cardDrawn",()=>{this.render()}),this.game.on("spreadLaid",()=>{this.render()}),this.game.on("spreadHit",()=>{this.render()}),this.game.on("cardDiscarded",()=>{this.render()}),this.game.on("gameOver",e=>{this.showGameOver(e)})}startGame(e){this.elements.startScreen.classList.add("hidden"),this.elements.gameContainer.dataset.playerCount=e,this.game.initialize(e)}render(){this.renderOpponents(),this.renderDeck(),this.renderDiscardPile(),this.renderSpreads(),this.renderPlayerHand(),this.renderPlayerInfo(),this.renderTurnIndicator(),this.renderMatchScores(),this.updateActionButtons()}renderOpponents(){this.elements.opponentArea.innerHTML="",this.elements.opponentLeftArea&&(this.elements.opponentLeftArea.innerHTML=""),this.elements.opponentRightArea&&(this.elements.opponentRightArea.innerHTML="");const e=this.game.players.filter(s=>!s.isHuman);if(this.game.players.length===4&&e.length===3)this.renderOpponentInArea(e[0],this.elements.opponentLeftArea),this.renderOpponentInArea(e[1],this.elements.opponentArea),this.renderOpponentInArea(e[2],this.elements.opponentRightArea);else for(const s of e)this.renderOpponentInArea(s,this.elements.opponentArea)}renderOpponentInArea(e,t){if(!t)return;const s=p.createOpponentHand(e);t.appendChild(s);const n=s.querySelector(".opponent-cards");n&&this.layoutManager.observe(n,"opponent")}renderDeck(){const e=this.game.getDeckCount();this.elements.deck.innerHTML="";const t=Math.min(e,5);for(let n=0;n<t;n++){const r=p.createCardBack();r.style.position="absolute",r.style.top=`${n*2}px`,r.style.left=`${n*2}px`,this.elements.deck.appendChild(r)}const s=document.createElement("span");s.id="deck-count",s.textContent=e,this.elements.deck.appendChild(s),this.canDrawFromDeck()?this.elements.deck.classList.remove("disabled"):this.elements.deck.classList.add("disabled")}renderDiscardPile(){this.elements.discardPile.innerHTML="";const e=this.game.getTopDiscard();if(e){const s=p.createCardElement(e,!0,!1);this.elements.discardPile.appendChild(s)}else{const s=p.createEmptyPile();this.elements.discardPile.appendChild(s)}const t=document.createElement("span");t.id="discard-label",t.textContent="Discard",this.elements.discardPile.appendChild(t),this.canDrawFromDiscard()?this.elements.discardPile.classList.remove("disabled"):this.elements.discardPile.classList.add("disabled")}renderSpreads(){this.elements.spreadsArea.innerHTML="";for(const e of this.game.spreadsOnTable){const t=p.createSpreadElement(e),s=this.game.phase===i.ACTION||this.game.phase===i.START_OF_TURN;if(this.selectedCards.length===1&&s){const r=this.getHumanPlayer().hand.find(a=>a.id===this.selectedCards[0]);r&&e.canAddCard(r)&&(t.classList.add("can-hit"),t.addEventListener("click",()=>{this.selectedSpread=e,this.handleHitSpread()}))}this.elements.spreadsArea.appendChild(t);const n=t.querySelector(".spread-cards");n&&this.layoutManager.observe(n,"spread")}}renderPlayerHand(){this.elements.playerHand.innerHTML="";const e=this.getHumanPlayer();if(!e)return;const s=this.game.getCurrentPlayer()===e&&(this.game.phase===i.ACTION||this.game.phase===i.START_OF_TURN);for(const n of e.hand){const r=p.createCardElement(n,!0,s);this.selectedCards.includes(n.id)&&r.classList.add("selected"),s&&r.addEventListener("click",()=>{this.toggleCardSelection(n.id)}),this.elements.playerHand.appendChild(r)}this.layoutManager.observe(this.elements.playerHand,"hand")}renderPlayerInfo(){const e=this.getHumanPlayer();e&&(this.elements.cardCount.textContent=`Cards: ${e.cardCount}`,this.elements.pointCount.textContent=`Points: ${e.calculatePoints()}`)}renderMatchScores(){this.elements.matchScores.innerHTML="";const e=this.game.getMatchScores();for(const{player:t,score:s}of e){const n=document.createElement("div");n.className=`player-score${t.isHuman?" human":""}`,n.innerHTML=`
        <span class="name">${t.isHuman?"You":t.name}:</span>
        <span class="points">${s} pts</span>
      `,this.elements.matchScores.appendChild(n)}}renderTurnIndicator(){const e=this.game.getCurrentPlayer(),t=e.isHuman;if(this.game.phase===i.GAME_OVER)this.elements.turnIndicator.textContent="Game Over",this.elements.turnIndicator.classList.remove("your-turn");else if(t){let s="Your turn";this.game.phase===i.START_OF_TURN?s="Spread cards or click Draw":this.game.phase===i.DRAW?s="Draw a card":this.game.phase===i.ACTION&&(s="Play cards or discard"),this.elements.turnIndicator.textContent=s,this.elements.turnIndicator.classList.add("your-turn")}else this.elements.turnIndicator.innerHTML=`
        <span class="thinking-indicator">
          ${e.name} thinking
          <span class="thinking-dots">
            <span></span><span></span><span></span>
          </span>
        </span>
      `,this.elements.turnIndicator.classList.remove("your-turn")}updateActionButtons(){const e=this.getHumanPlayer(),t=this.game.getCurrentPlayer()===e,s=this.game.phase===i.ACTION,n=this.game.phase===i.START_OF_TURN;this.game.phase,i.DRAW;const r=s||n,a=t&&r&&this.selectedCards.length>=3&&this.isValidSpreadSelection();this.elements.btnFormSpread.disabled=!a;const d=t&&r&&this.selectedCards.length===1&&this.canHitAnySpread();this.elements.btnHitSpread.disabled=!d;const h=t&&n&&e&&e.canKnock();if(this.elements.btnKnock.disabled=!h,this.elements.btnDraw){const c=t&&n;this.elements.btnDraw.disabled=!c,this.elements.btnDraw.style.display=n?"inline-block":"none"}const l=t&&s&&this.selectedCards.length===1;this.elements.btnDiscard.disabled=!l}toggleCardSelection(e){const t=this.selectedCards.indexOf(e);t===-1?this.selectedCards.push(e):this.selectedCards.splice(t,1),this.render()}clearSelection(){this.selectedCards=[],this.selectedSpread=null,this.render()}isValidSpreadSelection(){const e=this.getHumanPlayer(),t=this.selectedCards.map(s=>e.hand.find(n=>n.id===s)).filter(Boolean);return y.validate(t).valid}canHitAnySpread(){if(this.selectedCards.length!==1)return!1;const t=this.getHumanPlayer().hand.find(s=>s.id===this.selectedCards[0]);return t?this.game.spreadsOnTable.some(s=>s.canAddCard(t)):!1}canDrawFromDeck(){return this.game.isHumanTurn()&&(this.game.phase===i.DRAW||this.game.phase===i.START_OF_TURN)&&!this.game.isStockEmpty()}canDrawFromDiscard(){return this.game.isHumanTurn()&&(this.game.phase===i.DRAW||this.game.phase===i.START_OF_TURN)&&this.game.getTopDiscard()!==null}handleDrawFromDeck(){try{this.game.phase===i.START_OF_TURN&&this.game.proceedToDraw(),this.game.drawFromDeck()}catch(e){this.showMessage(e.message,"error")}}handleDrawFromDiscard(){try{this.game.phase===i.START_OF_TURN&&this.game.proceedToDraw(),this.game.drawFromDiscard()}catch(e){this.showMessage(e.message,"error")}}handleFormSpread(){try{const e=this.getHumanPlayer(),t=this.selectedCards.map(s=>e.hand.find(n=>n.id===s)).filter(Boolean);this.game.laySpread(t),this.clearSelection()}catch(e){this.showMessage(e.message,"error")}}handleHitSpread(){try{const t=this.getHumanPlayer().hand.find(s=>s.id===this.selectedCards[0]);this.selectedSpread||(this.selectedSpread=this.game.spreadsOnTable.find(s=>s.canAddCard(t))),t&&this.selectedSpread&&(this.game.hitSpread(t,this.selectedSpread),this.clearSelection())}catch(e){this.showMessage(e.message,"error")}}handleProceedToDraw(){try{this.game.proceedToDraw(),this.render()}catch(e){this.showMessage(e.message,"error")}}handleKnock(){try{this.game.knock()}catch(e){this.showMessage(e.message,"error")}}handleDiscard(){try{const t=this.getHumanPlayer().hand.find(s=>s.id===this.selectedCards[0]);t&&(this.game.discard(t),this.clearSelection())}catch(e){this.showMessage(e.message,"error")}}async handleAITurn(e){if(await this.delay(800),this.game.phase===i.START_OF_TURN){if(e.shouldKnock&&e.shouldKnock())try{this.game.knock();return}catch{}if(e.findAllSpreadsToLay){const n=e.findAllSpreadsToLay();for(const r of n)try{if(this.game.laySpread(r.cards),this.showMessage(`${e.name} laid a ${r.type}`,"info"),await this.delay(500),this.game.isGameOver())return}catch{}}if(e.findHitOpportunities){const n=e.findHitOpportunities(this.game.spreadsOnTable);for(const r of n)if(e.hasCard(r.card))try{if(this.game.hitSpread(r.card,r.spread),this.showMessage(`${e.name} hit a spread`,"info"),await this.delay(400),this.game.isGameOver())return}catch{}}this.game.proceedToDraw(),this.render()}const t=this.game.getTopDiscard(),s=e.decideDraw?e.decideDraw(t):"deck";if(await this.delay(400),s==="discard"&&t?(this.game.drawFromDiscard(),this.showMessage(`${e.name} drew from discard`,"info")):(this.game.drawFromDeck(),this.showMessage(`${e.name} drew from deck`,"info")),await this.delay(600),e.findAllSpreadsToLay){const n=e.findAllSpreadsToLay();for(const r of n)try{if(this.game.laySpread(r.cards),this.showMessage(`${e.name} laid a ${r.type}`,"info"),await this.delay(500),this.game.isGameOver())return}catch{}}if(e.findHitOpportunities){const n=e.findHitOpportunities(this.game.spreadsOnTable);for(const r of n)if(e.hasCard(r.card))try{if(this.game.hitSpread(r.card,r.spread),this.showMessage(`${e.name} hit a spread`,"info"),await this.delay(400),this.game.isGameOver())return}catch{}}if(e.hand.length>0&&!this.game.isGameOver()){const n=e.decideDiscard?e.decideDiscard():e.hand[0];n&&(await this.delay(400),this.game.discard(n),this.showMessage(`${e.name} discarded ${n.toString()}`,"info"))}}showGameOver(e){const{winner:t,condition:s,knocker:n}=e,r=t.isHuman,a=this.game.applyRoundScoring();if(this.game.checkMatchEnd()){const c=this.game.matchWinner,u=c.isHuman;this.elements.gameOverTitle.textContent=u?"Match Won!":"Match Lost!",this.elements.gameOverMessage.textContent=`${c.isHuman?"You win":c.name+" wins"} the match!`,this.elements.btnContinueRound.classList.add("hidden")}else{this.elements.gameOverTitle.textContent=`Round ${this.game.roundNumber} - ${r?"You Win!":"You Lose!"}`;let c="";switch(s){case"tonk":c=`${t.isHuman?"You went":t.name+" went"} out with an empty hand!`;break;case"initial-tonk":c=`${t.isHuman?"You had":t.name+" had"} 49-50 points - Initial Tonk!`;break;case"knock":c=`${n.isHuman?"You dropped":n.name+" dropped"} and had the lowest points!`;break;case"caught":c=`${n.isHuman?"You dropped":n.name+" dropped"} but ${t.isHuman?"you had":t.name+" had"} fewer points!`;break;case"stock-empty":c=`Stock ran out! ${t.isHuman?"You had":t.name+" had"} the lowest points.`;break;default:c=`${t.isHuman?"You win":t.name+" wins"}!`}this.elements.gameOverMessage.textContent=c,this.elements.btnContinueRound.classList.remove("hidden")}this.elements.finalScores.innerHTML="";const h=document.createElement("div");h.className="score-row score-header",h.innerHTML=`
      <span>Player</span>
      <span>Hand</span>
      <span>Match Total</span>
    `,this.elements.finalScores.appendChild(h);const l=this.game.getScores();l.sort((c,u)=>c.matchScore-u.matchScore);for(const c of l){const u=document.createElement("div");u.className="score-row",c.player===t&&u.classList.add("winner");const w=a.find(b=>b.player===c.player),I=w?` (+${w.pointsAdded})`:"";u.innerHTML=`
        <span>${c.player.isHuman?"You":c.player.name}</span>
        <span>${c.points} pts</span>
        <span>${c.matchScore}${I}</span>
      `,this.elements.finalScores.appendChild(u)}this.elements.gameOverModal.classList.remove("hidden")}showMessage(e,t="info"){this.elements.messageArea.textContent=e,this.elements.messageArea.className=`visible ${t}`,this.messageTimeout&&clearTimeout(this.messageTimeout),this.messageTimeout=setTimeout(()=>{this.elements.messageArea.classList.remove("visible")},2500)}getHumanPlayer(){return this.game.players.find(e=>e.isHuman)}delay(e){return new Promise(t=>setTimeout(t,e))}initializeTheme(){const e=q();this.setDeckTheme(e,!1)}setDeckTheme(e,t=!0){document.body.dataset.deckTheme=e,this.elements.themeOptions.forEach(s=>{s.dataset.theme===e?(s.classList.add("selected"),s.querySelector(".theme-preview").classList.add("selected")):(s.classList.remove("selected"),s.querySelector(".theme-preview").classList.remove("selected"))}),t&&j(e)}}document.addEventListener("DOMContentLoaded",()=>{const o=new K;new Q(o)});
